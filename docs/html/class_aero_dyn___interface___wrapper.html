<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>&#39;FASTInterface&#39;: AeroDyn_Interface_Wrapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&#39;FASTInterface&#39;
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_aero_dyn___interface___wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AeroDyn_Interface_Wrapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a wrapper for AeroDyn_Interface, which is written in FORTRAN. Its main purpose is to provide Aerodyn with inputs, for which it can return reaction loads on the hub. It also changes from ProteusDS' z-positive-down coordinate system to AeroDyn's z-positive-up coordinate system.  
 <a href="class_aero_dyn___interface___wrapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_aero_dyn___interface___wrapper_8h_source.html">AeroDyn_Interface_Wrapper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">HubReactionLoads</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_aero_dyn___interface___wrapper_1_1_input.html">Input</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aba4f03bde29cc7fc61556325ebd40c64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#aba4f03bde29cc7fc61556325ebd40c64">InitAerodyn</a> (const char *inputFilename, const char *outputFilename, double timestep, int numBlades, double hubRadius, double precone, bool useAddedMass, double coeffAddedMass, const Vector3d &amp;hubPosition, const Matrix3d &amp;hubOrientation, const Vector3d &amp;hubVel, const Vector3d &amp;hubAcc, const Vector3d &amp;hubRotationalVel, const Vector3d &amp;hubRotationalAcc, double bladePitch)</td></tr>
<tr class="memdesc:aba4f03bde29cc7fc61556325ebd40c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes AeroDyn by loading input files and setting initial hub state.  <a href="class_aero_dyn___interface___wrapper.html#aba4f03bde29cc7fc61556325ebd40c64">More...</a><br /></td></tr>
<tr class="separator:aba4f03bde29cc7fc61556325ebd40c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f49f937a36e78a1a3609e0a4abdc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a22f49f937a36e78a1a3609e0a4abdc66">InitInflows</a> (const std::vector&lt; double &gt; &amp;inflowVel, const std::vector&lt; double &gt; &amp;inflowAcc)</td></tr>
<tr class="memdesc:a22f49f937a36e78a1a3609e0a4abdc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the inflows. Note, inflow velocities are in global coordinate system.  <a href="class_aero_dyn___interface___wrapper.html#a22f49f937a36e78a1a3609e0a4abdc66">More...</a><br /></td></tr>
<tr class="separator:a22f49f937a36e78a1a3609e0a4abdc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891c89d1f37f9694c049d1fe2cb3894"><td class="memItemLeft" align="right" valign="top"><a id="ac891c89d1f37f9694c049d1fe2cb3894"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SaveCurrentStates</b> ()</td></tr>
<tr class="separator:ac891c89d1f37f9694c049d1fe2cb3894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261110ab38c660347aa8793e14de4bdf"><td class="memItemLeft" align="right" valign="top"><a id="a261110ab38c660347aa8793e14de4bdf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RestoreSavedStates</b> ()</td></tr>
<tr class="separator:a261110ab38c660347aa8793e14de4bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83efebceeba09a5730bbd4627e7f229d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a83efebceeba09a5730bbd4627e7f229d">Set_Inputs_Hub</a> (double time, const Vector3d &amp;hubPosition, const Matrix3d &amp;hubOrientation, const Vector3d &amp;hubVel, const Vector3d &amp;hubAcc, const Vector3d &amp;hubAngularVel, const Vector3d &amp;hubAngularAcc, double bladePitch)</td></tr>
<tr class="memdesc:a83efebceeba09a5730bbd4627e7f229d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the hub motion variables, changing the positions of the nodes accordingly.  <a href="class_aero_dyn___interface___wrapper.html#a83efebceeba09a5730bbd4627e7f229d">More...</a><br /></td></tr>
<tr class="separator:a83efebceeba09a5730bbd4627e7f229d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83233cd9085b565593cbbe304d30980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#ab83233cd9085b565593cbbe304d30980">Set_Inputs_HubAcceleration</a> (const Vector3d &amp;hubAcc, const Vector3d &amp;hubAngularAcc)</td></tr>
<tr class="memdesc:ab83233cd9085b565593cbbe304d30980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the acceleration inputs only.  <a href="class_aero_dyn___interface___wrapper.html#ab83233cd9085b565593cbbe304d30980">More...</a><br /></td></tr>
<tr class="separator:ab83233cd9085b565593cbbe304d30980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b9580fca86c4edaa714b716b82f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a008b9580fca86c4edaa714b716b82f2c">Set_Inputs_Inflow</a> (const std::vector&lt; double &gt; &amp;inflowVel, const std::vector&lt; double &gt; &amp;inflowAcc)</td></tr>
<tr class="memdesc:a008b9580fca86c4edaa714b716b82f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flow velocity and acceleration at the next time-step. Note, inflow velocities are in global coordinate system.  <a href="class_aero_dyn___interface___wrapper.html#a008b9580fca86c4edaa714b716b82f2c">More...</a><br /></td></tr>
<tr class="separator:a008b9580fca86c4edaa714b716b82f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590d1e1bb7dc56dd4b08a746e5276cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">HubReactionLoads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a590d1e1bb7dc56dd4b08a746e5276cb9">CalcOutput</a> ()</td></tr>
<tr class="memdesc:a590d1e1bb7dc56dd4b08a746e5276cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hub reaction loads.  <a href="class_aero_dyn___interface___wrapper.html#a590d1e1bb7dc56dd4b08a746e5276cb9">More...</a><br /></td></tr>
<tr class="separator:a590d1e1bb7dc56dd4b08a746e5276cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b782515d1d983f18501f80b8285a1b4"><td class="memItemLeft" align="right" valign="top"><a id="a1b782515d1d983f18501f80b8285a1b4"></a>
<a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">HubReactionLoads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a1b782515d1d983f18501f80b8285a1b4">GetOutput</a> () const</td></tr>
<tr class="memdesc:a1b782515d1d983f18501f80b8285a1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current outputs <b>Note:</b> the values returned by this are part of what is saved when SaveCurrentStates is called, so if this is called after calling RestoreSavedStates, then the outputs will be from those saved states. <br /></td></tr>
<tr class="separator:a1b782515d1d983f18501f80b8285a1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669533a22e0f6ba60c30c6d5f6a2306"><td class="memItemLeft" align="right" valign="top"><a id="a5669533a22e0f6ba60c30c6d5f6a2306"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a5669533a22e0f6ba60c30c6d5f6a2306">Advance_InputWindow</a> ()</td></tr>
<tr class="memdesc:a5669533a22e0f6ba60c30c6d5f6a2306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles the two inputs: curr_input=next_input. <br /></td></tr>
<tr class="separator:a5669533a22e0f6ba60c30c6d5f6a2306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab351cbcceda676f2b38a7e027c7b4def"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#ab351cbcceda676f2b38a7e027c7b4def">GetInput_HubAcc</a> () const</td></tr>
<tr class="memdesc:ab351cbcceda676f2b38a7e027c7b4def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the acceleration input at the next timestep.  <a href="class_aero_dyn___interface___wrapper.html#ab351cbcceda676f2b38a7e027c7b4def">More...</a><br /></td></tr>
<tr class="separator:ab351cbcceda676f2b38a7e027c7b4def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5548c1c3e2d32b7e0f04d9cd9a181d31"><td class="memItemLeft" align="right" valign="top"><a id="a5548c1c3e2d32b7e0f04d9cd9a181d31"></a>
Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>GetInput_HubRotAcc</b> () const</td></tr>
<tr class="separator:a5548c1c3e2d32b7e0f04d9cd9a181d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514403fc4652499b2b8cd18c3e0623b3"><td class="memItemLeft" align="right" valign="top"><a id="a514403fc4652499b2b8cd18c3e0623b3"></a>
Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><b>GetInput_HubOrient</b> () const</td></tr>
<tr class="separator:a514403fc4652499b2b8cd18c3e0623b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a17f25396dc6de8d62011ab6bc61fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a2a17f25396dc6de8d62011ab6bc61fd3">GetBladeNodePositions</a> (std::vector&lt; double &gt; &amp;bladeNodePositions)</td></tr>
<tr class="memdesc:a2a17f25396dc6de8d62011ab6bc61fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once updateHubState has been called, we call this to get where those hub kinematics put the blade nodes.  <a href="class_aero_dyn___interface___wrapper.html#a2a17f25396dc6de8d62011ab6bc61fd3">More...</a><br /></td></tr>
<tr class="separator:a2a17f25396dc6de8d62011ab6bc61fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8663c790efc161371a25b8add74a6edb"><td class="memItemLeft" align="right" valign="top"><a id="a8663c790efc161371a25b8add74a6edb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a8663c790efc161371a25b8add74a6edb">GetNumNodes</a> () const</td></tr>
<tr class="memdesc:a8663c790efc161371a25b8add74a6edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of nodes (call after InitAerodyn) <br /></td></tr>
<tr class="separator:a8663c790efc161371a25b8add74a6edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f924a11778f663779503ada269606c2"><td class="memItemLeft" align="right" valign="top"><a id="a2f924a11778f663779503ada269606c2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a2f924a11778f663779503ada269606c2">GetNumBlades</a> () const</td></tr>
<tr class="memdesc:a2f924a11778f663779503ada269606c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of blades (call after InitAerodyn) <br /></td></tr>
<tr class="separator:a2f924a11778f663779503ada269606c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0783af5d2f3e13dbe43e2f86dde8b38b"><td class="memItemLeft" align="right" valign="top"><a id="a0783af5d2f3e13dbe43e2f86dde8b38b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a0783af5d2f3e13dbe43e2f86dde8b38b">GetTurbineDiameter</a> () const</td></tr>
<tr class="memdesc:a0783af5d2f3e13dbe43e2f86dde8b38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the diameter of the turbine (call after InitAeroDyn) <br /></td></tr>
<tr class="separator:a0783af5d2f3e13dbe43e2f86dde8b38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b049f70154c822b2ca5f5a82d5b101c"><td class="memItemLeft" align="right" valign="top"><a id="a8b049f70154c822b2ca5f5a82d5b101c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a8b049f70154c822b2ca5f5a82d5b101c">UpdateStates</a> ()</td></tr>
<tr class="memdesc:a8b049f70154c822b2ca5f5a82d5b101c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates from the current states at time_curr to time_next, and stores the new states in the predicted states (in the FORTRAN layer) <br /></td></tr>
<tr class="separator:a8b049f70154c822b2ca5f5a82d5b101c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc0263905781eed9a71415d401faa4a"><td class="memItemLeft" align="right" valign="top"><a id="a6dc0263905781eed9a71415d401faa4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a6dc0263905781eed9a71415d401faa4a">CopyStates_Pred_to_Curr</a> ()</td></tr>
<tr class="memdesc:a6dc0263905781eed9a71415d401faa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to the FORTRAN subroutine of the same name (see AeroDyn_Interface project) <br /></td></tr>
<tr class="separator:a6dc0263905781eed9a71415d401faa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20737575c60b0d3b5d5e639225af7edf"><td class="memItemLeft" align="right" valign="top"><a id="a20737575c60b0d3b5d5e639225af7edf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a20737575c60b0d3b5d5e639225af7edf">PrintOutputLine</a> ()</td></tr>
<tr class="memdesc:a20737575c60b0d3b5d5e639225af7edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to the output file the one-line results from the last call to CalcOutput. <br /></td></tr>
<tr class="separator:a20737575c60b0d3b5d5e639225af7edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35673573f68f342147f1103f3ae17128"><td class="memItemLeft" align="right" valign="top"><a id="a35673573f68f342147f1103f3ae17128"></a>
<a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">HubReactionLoads</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetHubReactionLoads</b> () const</td></tr>
<tr class="separator:a35673573f68f342147f1103f3ae17128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f39c0dc52d0d9cf3a6d5eb85137766"><td class="memItemLeft" align="right" valign="top"><a id="ae9f39c0dc52d0d9cf3a6d5eb85137766"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#ae9f39c0dc52d0d9cf3a6d5eb85137766">GetTSR</a> () const</td></tr>
<tr class="memdesc:ae9f39c0dc52d0d9cf3a6d5eb85137766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the TSR of the current outputs. <br /></td></tr>
<tr class="separator:ae9f39c0dc52d0d9cf3a6d5eb85137766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba32f1c5e9c10292df784b3fa2b9cdc"><td class="memItemLeft" align="right" valign="top"><a id="a1ba32f1c5e9c10292df784b3fa2b9cdc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a1ba32f1c5e9c10292df784b3fa2b9cdc">GetTorque</a> () const</td></tr>
<tr class="memdesc:a1ba32f1c5e9c10292df784b3fa2b9cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the torque resulting from the current outputs. <br /></td></tr>
<tr class="separator:a1ba32f1c5e9c10292df784b3fa2b9cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669548c10e9ca4916e65fbcb9fe5b0dd"><td class="memItemLeft" align="right" valign="top"><a id="a669548c10e9ca4916e65fbcb9fe5b0dd"></a>
Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a669548c10e9ca4916e65fbcb9fe5b0dd">GetForce</a> () const</td></tr>
<tr class="memdesc:a669548c10e9ca4916e65fbcb9fe5b0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the force resulting from the current outputs. <br /></td></tr>
<tr class="separator:a669548c10e9ca4916e65fbcb9fe5b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c53719e1482354910d8226f02583fc9"><td class="memItemLeft" align="right" valign="top"><a id="a6c53719e1482354910d8226f02583fc9"></a>
Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a6c53719e1482354910d8226f02583fc9">GetMoment</a> () const</td></tr>
<tr class="memdesc:a6c53719e1482354910d8226f02583fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the moment resulting from the current outputs. <br /></td></tr>
<tr class="separator:a6c53719e1482354910d8226f02583fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdefb584bb1e806b3d91cf03a3a21a3"><td class="memItemLeft" align="right" valign="top"><a id="a3bdefb584bb1e806b3d91cf03a3a21a3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a3bdefb584bb1e806b3d91cf03a3a21a3">GetBladePitch</a> () const</td></tr>
<tr class="memdesc:a3bdefb584bb1e806b3d91cf03a3a21a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last actual pitch value. <br /></td></tr>
<tr class="separator:a3bdefb584bb1e806b3d91cf03a3a21a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9ea868c23ae0498a5f401ce7bc38dedb"><td class="memItemLeft" align="right" valign="top"><a id="a9ea868c23ae0498a5f401ce7bc38dedb"></a>
Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a9ea868c23ae0498a5f401ce7bc38dedb">Transform_PDStoAD</a> (const Vector3d &amp;v) const</td></tr>
<tr class="memdesc:a9ea868c23ae0498a5f401ce7bc38dedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a vector expressed in a z-positive-down coordinate system, to a z-positive-up coordinate system. <br /></td></tr>
<tr class="separator:a9ea868c23ae0498a5f401ce7bc38dedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf58e36cb25e11b9bee83848c0a74fc"><td class="memItemLeft" align="right" valign="top"><a id="a0bf58e36cb25e11b9bee83848c0a74fc"></a>
Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a0bf58e36cb25e11b9bee83848c0a74fc">Transform_ADtoPDS</a> (const Vector3d &amp;v) const</td></tr>
<tr class="memdesc:a0bf58e36cb25e11b9bee83848c0a74fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a vector expressed in a z-positive-up coordinate system, to a z-positive-down coordinate system. <br /></td></tr>
<tr class="separator:a0bf58e36cb25e11b9bee83848c0a74fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa97cbfbc200febb1c3011b88820ccb"><td class="memItemLeft" align="right" valign="top"><a id="a6fa97cbfbc200febb1c3011b88820ccb"></a>
Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a6fa97cbfbc200febb1c3011b88820ccb">TransformOrientation</a> (const Matrix3d &amp;orientation) const</td></tr>
<tr class="memdesc:a6fa97cbfbc200febb1c3011b88820ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the local to global orientation matrix from z-down to z-up coordinate system. <br /></td></tr>
<tr class="separator:a6fa97cbfbc200febb1c3011b88820ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857f05b5e37e311b0c8603b69a0f6f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a857f05b5e37e311b0c8603b69a0f6f9d">TransformInflows_PDStoAD</a> (const std::vector&lt; double &gt; &amp;pdsInflowVel, const std::vector&lt; double &gt; &amp;pdsInflowAcc)</td></tr>
<tr class="separator:a857f05b5e37e311b0c8603b69a0f6f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa6a7b33938a887d22cd444b56e00de17"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#aa6a7b33938a887d22cd444b56e00de17">simulationInstance</a></td></tr>
<tr class="separator:aa6a7b33938a887d22cd444b56e00de17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe38bd1791039be9eaa78c5415718e0"><td class="memItemLeft" align="right" valign="top"><a id="a4fe38bd1791039be9eaa78c5415718e0"></a>
<a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">HubReactionLoads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a4fe38bd1791039be9eaa78c5415718e0">hubReactionLoads</a></td></tr>
<tr class="memdesc:a4fe38bd1791039be9eaa78c5415718e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saved reaction loads from last call to UpdateStates. <br /></td></tr>
<tr class="separator:a4fe38bd1791039be9eaa78c5415718e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafb71d2e74c1cf770e50b5b477ac6ff"><td class="memItemLeft" align="right" valign="top"><a id="aeafb71d2e74c1cf770e50b5b477ac6ff"></a>
<a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">HubReactionLoads</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hubReactionLoads_saved</b></td></tr>
<tr class="separator:aeafb71d2e74c1cf770e50b5b477ac6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d6bdb0f87d348b0675b099387cd203"><td class="memItemLeft" align="right" valign="top"><a id="a78d6bdb0f87d348b0675b099387cd203"></a>
<a class="el" href="struct_aero_dyn___interface___wrapper_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><b>input</b></td></tr>
<tr class="separator:a78d6bdb0f87d348b0675b099387cd203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ae4f44d6012c51a1c55e7f2412d0e2"><td class="memItemLeft" align="right" valign="top"><a id="ad9ae4f44d6012c51a1c55e7f2412d0e2"></a>
<a class="el" href="struct_aero_dyn___interface___wrapper_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><b>input_saved</b></td></tr>
<tr class="separator:ad9ae4f44d6012c51a1c55e7f2412d0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aac7a977eb9937e70212da128208c6"><td class="memItemLeft" align="right" valign="top"><a id="a33aac7a977eb9937e70212da128208c6"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aerodynInflowVel</b></td></tr>
<tr class="separator:a33aac7a977eb9937e70212da128208c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef16aa8cd8afd0cf6faf9bdc05506ff"><td class="memItemLeft" align="right" valign="top"><a id="afef16aa8cd8afd0cf6faf9bdc05506ff"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aerodynInflowVel_saved</b></td></tr>
<tr class="separator:afef16aa8cd8afd0cf6faf9bdc05506ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124776cb9b1e0759fdff673233017709"><td class="memItemLeft" align="right" valign="top"><a id="a124776cb9b1e0759fdff673233017709"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#a124776cb9b1e0759fdff673233017709">aerodynInflowAcc</a></td></tr>
<tr class="memdesc:a124776cb9b1e0759fdff673233017709"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds the flow velocities in AeroDyn's coordinate system <br /></td></tr>
<tr class="separator:a124776cb9b1e0759fdff673233017709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547248eb50ea2beaf2cf880a3030229f"><td class="memItemLeft" align="right" valign="top"><a id="a547248eb50ea2beaf2cf880a3030229f"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aerodynInflowAcc_saved</b></td></tr>
<tr class="separator:a547248eb50ea2beaf2cf880a3030229f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb44ac188645f72e5632ff97cb94bf46"><td class="memItemLeft" align="right" valign="top"><a id="aeb44ac188645f72e5632ff97cb94bf46"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aero_dyn___interface___wrapper.html#aeb44ac188645f72e5632ff97cb94bf46">turbineDiameter</a></td></tr>
<tr class="memdesc:aeb44ac188645f72e5632ff97cb94bf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds the flow accelerations in AeroDyn's coordinate system <br /></td></tr>
<tr class="separator:aeb44ac188645f72e5632ff97cb94bf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a0f033b18e6b676442c0be6fb1037"><td class="memItemLeft" align="right" valign="top"><a id="a918a0f033b18e6b676442c0be6fb1037"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>pitch</b></td></tr>
<tr class="separator:a918a0f033b18e6b676442c0be6fb1037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7759c4bd6f5c687b9272b993a73f6796"><td class="memItemLeft" align="right" valign="top"><a id="a7759c4bd6f5c687b9272b993a73f6796"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>pitch_saved</b></td></tr>
<tr class="separator:a7759c4bd6f5c687b9272b993a73f6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821df1bcff2f9928bcf11a74f136a24f"><td class="memItemLeft" align="right" valign="top"><a id="a821df1bcff2f9928bcf11a74f136a24f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>totalNodes</b></td></tr>
<tr class="separator:a821df1bcff2f9928bcf11a74f136a24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11af895e17cb5f2a22a7d99ec738c263"><td class="memItemLeft" align="right" valign="top"><a id="a11af895e17cb5f2a22a7d99ec738c263"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nBlades</b></td></tr>
<tr class="separator:a11af895e17cb5f2a22a7d99ec738c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3310fdb009cf5d757093e880e59b9ce2"><td class="memItemLeft" align="right" valign="top"><a id="a3310fdb009cf5d757093e880e59b9ce2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nNodes</b></td></tr>
<tr class="separator:a3310fdb009cf5d757093e880e59b9ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a wrapper for AeroDyn_Interface, which is written in FORTRAN. Its main purpose is to provide Aerodyn with inputs, for which it can return reaction loads on the hub. It also changes from ProteusDS' z-positive-down coordinate system to AeroDyn's z-positive-up coordinate system. </p>
<dl class="section author"><dt>Author</dt><dd>Dustin Condon </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Aug 2020</dd></dl>
<p>This interface has two features:</p>
<p>1.The interface allows one to save all of AeroDyn's states and restore them by calling SaveCurrentStates and RestoreSavedStates, respectively. This is used to take temporary updates when the driver program is calling this AeroDyn interface during the intermediate steps of its explicit integrator. The process is covered in the Fall 2019 work term report, and is refered to as "modified loose coupling". The implementation on AeroDyn_Interface's end has since changed to this "save and restore states" method since that report, but the basic idea of the method is the same.</p>
<p>2.The other feature is that the interface doesn't overwrite the existing states when UpdateStates is called. Instead it keeps two states, "current" and "predicted". When UpdateStates is called, the "current" states are integrated, and the result is saved in "predicted", so "current" remains unchanged. This allows for this module to be coordinate with others using the same predictor-corrector method used in OpenFAST. So UpdateStates can be called multiple times using different inputs until the "predicted" states have been corrected enough times. Then the "predicted" states can be copied into the "current" states by calling CopyStates_Pred_to_Curr.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Example:</h2>
<p>The expected order of function calls is follows (this example is without using any corrector steps) </p><div class="fragment"><div class="line"><span class="comment">//----------- initialization --------------</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#aba4f03bde29cc7fc61556325ebd40c64">InitAerodyn</a>(...);           <span class="comment">// passing driver input file name, hub kinematics, and blade pitch; receiving the total number of nodes used</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a2a17f25396dc6de8d62011ab6bc61fd3">GetBladeNodePositions</a>();    <span class="comment">// receiving the positions of the blade nodes in global coordinate system</span></div>
<div class="line">InitInputs_Inflow(...);     <span class="comment">// passing the inflows at time_act=0</span></div>
<div class="line"><span class="comment">//----------- simulation loop -------------</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a83efebceeba09a5730bbd4627e7f229d">Set_Inputs_Hub</a>(...);        <span class="comment">// passing hubstate at time_act = 0</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a2a17f25396dc6de8d62011ab6bc61fd3">GetBladeNodePositions</a>();    <span class="comment">// ...</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a008b9580fca86c4edaa714b716b82f2c">Set_Inputs_Inflow</a>(...);     <span class="comment">// ...</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a8b049f70154c822b2ca5f5a82d5b101c">UpdateStates</a>();             <span class="comment">// passing the inflow at time_act = 0</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a6dc0263905781eed9a71415d401faa4a">CopyStates_Pred_to_Curr</a>();  <span class="comment">// ...</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a5669533a22e0f6ba60c30c6d5f6a2306">Advance_InputWindow</a>();      <span class="comment">// ... </span></div>
<div class="line"><span class="comment">//---next timestep---</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a83efebceeba09a5730bbd4627e7f229d">Set_Inputs_Hub</a>(...);        <span class="comment">// passing hubstate at time_act = t_1</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a2a17f25396dc6de8d62011ab6bc61fd3">GetBladeNodePositions</a>();    <span class="comment">// ...</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a008b9580fca86c4edaa714b716b82f2c">Set_Inputs_Inflow</a>(...);     <span class="comment">//</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a8b049f70154c822b2ca5f5a82d5b101c">UpdateStates</a>();             <span class="comment">// passing the inflow at time_act = t_1</span></div>
<div class="line">CopyState_Pred_to_Curr();   <span class="comment">//</span></div>
<div class="line"><a class="code" href="class_aero_dyn___interface___wrapper.html#a5669533a22e0f6ba60c30c6d5f6a2306">Advance_InputWindow</a>();      <span class="comment">//</span></div>
<div class="line">                            <span class="comment">// etc...</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a590d1e1bb7dc56dd4b08a746e5276cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590d1e1bb7dc56dd4b08a746e5276cb9">&#9670;&nbsp;</a></span>CalcOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_aero_dyn___interface___wrapper_1_1_hub_reaction_loads.html">AeroDyn_Interface_Wrapper::HubReactionLoads</a> AeroDyn_Interface_Wrapper::CalcOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the hub reaction loads. </p>
<p><b>Note:</b> Should be called after either:</p><ol type="1">
<li>Updating the states, or</li>
<li>Changing the inputs at global_time_next </li>
</ol>

</div>
</div>
<a id="a2a17f25396dc6de8d62011ab6bc61fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a17f25396dc6de8d62011ab6bc61fd3">&#9670;&nbsp;</a></span>GetBladeNodePositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::GetBladeNodePositions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>bladeNodePositions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once updateHubState has been called, we call this to get where those hub kinematics put the blade nodes. </p>
<p>The format expected is the same as initInflows. So indices 0,1,2 correspond to the x,y,z position of node 0; and inflow indices 0,1,2 represent the x,y,z inflow velocity for that node. </p>

</div>
</div>
<a id="ab351cbcceda676f2b38a7e027c7b4def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab351cbcceda676f2b38a7e027c7b4def">&#9670;&nbsp;</a></span>GetInput_HubAcc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d AeroDyn_Interface_Wrapper::GetInput_HubAcc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the acceleration input at the next timestep. </p>
<p><b>Note:</b> used in the input solver in the coordinating class</p>
<dl class="section return"><dt>Returns</dt><dd>acceleration at next timestep of the hub in the global coordinate system. </dd></dl>

</div>
</div>
<a id="aba4f03bde29cc7fc61556325ebd40c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4f03bde29cc7fc61556325ebd40c64">&#9670;&nbsp;</a></span>InitAerodyn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::InitAerodyn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlades</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hubRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAddedMass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeffAddedMass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>hubOrientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubRotationalVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubRotationalAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bladePitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes AeroDyn by loading input files and setting initial hub state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputFilename</td><td>filename (including path) of the AeroDyn input file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFilename</td><td>root name of the output file to be generated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestep</td><td>the timestep that AeroDyn will take (sec) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlades</td><td>the number of blades to use in the simulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubRadius</td><td>the distance from hub center to blade root </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precone</td><td>the precone angle of the blades (radians) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">have</td><td>AeroDyn include added mass effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficient</td><td>of added mass (only used when useAddedMass is true) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubPosition</td><td>global position of the hub center in ProteusDS's coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubOrientation</td><td>3x3 orientation matrix of the hub </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubVelocity</td><td>(metres/sec) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubAcceleration</td><td>(metres/sec^2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubRotationalVel</td><td>axis-angle form in global coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hubRotationalAcc</td><td>axis-angle form in global coordinate system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bladePitch</td><td>radians </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f49f937a36e78a1a3609e0a4abdc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f49f937a36e78a1a3609e0a4abdc66">&#9670;&nbsp;</a></span>InitInflows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::InitInflows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inflowVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inflowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the inflows. Note, inflow velocities are in global coordinate system. </p>
<hr  />
<p> The format expected is (in global coordinate system) inflows[0] inflow velocity in x direction at node 0 ...[1] inflow velocity in y direction at node 0 ...[2] inflow velocity in z direction at node 0 ...[3] inflow velocity in x direction at node 1 ... etc</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inflowVel</td><td>a serialized vector of the inflow velocity at each blade node </td></tr>
    <tr><td class="paramname">inflowAcc</td><td>a serialized vector of the inflow acceleration at each blade node (not used when added mass is not enabled), so could just pass the inflowVel vector twice in that case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>maybe make version that doesn't require the acceleration for when added mass isn't enabled </dd></dl>

</div>
</div>
<a id="a83efebceeba09a5730bbd4627e7f229d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83efebceeba09a5730bbd4627e7f229d">&#9670;&nbsp;</a></span>Set_Inputs_Hub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::Set_Inputs_Hub </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>hubOrientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubAngularVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubAngularAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bladePitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the hub motion variables, changing the positions of the nodes accordingly. </p>
<p><b>Note:</b> call this before calling GetBladeNodePositions because this will inform where the node positions are. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time the inputs describe (sec) </td></tr>
    <tr><td class="paramname">hubPosition</td><td>position of the hub in global coordinate system (meters) </td></tr>
    <tr><td class="paramname">hubOrientation</td><td>orientation matrix in ProteusDS' z-positive-down coordinate system </td></tr>
    <tr><td class="paramname">hubVel</td><td>velocity of the hub in ProteusDS' global coordinate system (meters/sec) </td></tr>
    <tr><td class="paramname">hubAcc</td><td>acceleration of the hub in ProteusDS' global coordinate system (m/sec^2) </td></tr>
    <tr><td class="paramname">hubAngularVel</td><td>angular velocity of the hub in ProteusDS' global coordinate system (axis-angle) </td></tr>
    <tr><td class="paramname">hubAngularAccangular</td><td>angular velocity of the hub in ProteusDS' global coordinate system (axis-angle) </td></tr>
    <tr><td class="paramname">bladePitch</td><td>(radians) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>the <b>time</b> parameter should always be time_curr + timestep. Any interpolation/extrapolation should be done outside this function. </dd></dl>

</div>
</div>
<a id="ab83233cd9085b565593cbbe304d30980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83233cd9085b565593cbbe304d30980">&#9670;&nbsp;</a></span>Set_Inputs_HubAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::Set_Inputs_HubAcceleration </td>
          <td>(</td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>hubAngularAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the acceleration inputs only. </p>
<p>The expected use of this function is to perturb the components indivually in order to calculate the partial derivatives of the residual function w.r.t. acceleration inputs, which is a composite function of CalcOutput function </p>

</div>
</div>
<a id="a008b9580fca86c4edaa714b716b82f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b9580fca86c4edaa714b716b82f2c">&#9670;&nbsp;</a></span>Set_Inputs_Inflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::Set_Inputs_Inflow </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inflowVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inflowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flow velocity and acceleration at the next time-step. Note, inflow velocities are in global coordinate system. </p>
<hr  />
<p> The format expected is (in global coordinate system) inflows[0] inflow velocity in x direction at node 0 ...[1] inflow velocity in y direction at node 0 ...[2] inflow velocity in z direction at node 0 ...[3] inflow velocity in x direction at node 1 ... etc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inflowVel</td><td>a serialized vector of the inflow velocity at each blade node </td></tr>
    <tr><td class="paramname">inflowAcc</td><td>a serialized vector of the inflow acceleration at each blade node; not used when added mass is not enabled, so could just pass the inflowVel vector twice in that case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>maybe make version that doesn't require the acceleration for when added mass isn't enabled </dd></dl>

</div>
</div>
<a id="a857f05b5e37e311b0c8603b69a0f6f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857f05b5e37e311b0c8603b69a0f6f9d">&#9670;&nbsp;</a></span>TransformInflows_PDStoAD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AeroDyn_Interface_Wrapper::TransformInflows_PDStoAD </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pdsInflowVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pdsInflowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>updates aerodynInflows with transformed pdsInflows</p>
<p>The transformation from ProteusDS's coordinate system and that of AeroDyn is done by negating the y and z components. This is because one is positive-z-up, while the other is positive-z-down. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa6a7b33938a887d22cd444b56e00de17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a7b33938a887d22cd444b56e00de17">&#9670;&nbsp;</a></span>simulationInstance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* AeroDyn_Interface_Wrapper::simulationInstance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the turbine instance pointer for the current instance of the class (points to a memory location allocated by the layer of the project; the data pointed to is a FORTRAN type) </p><dl class="section see"><dt>See also</dt><dd>FORTRAN project AeroDyn_Interface </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>FASTInterface/src/<a class="el" href="_aero_dyn___interface___wrapper_8h_source.html">AeroDyn_Interface_Wrapper.h</a></li>
<li>FASTInterface/src/AeroDyn_Interface_Wrapper.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_a6dc0263905781eed9a71415d401faa4a"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#a6dc0263905781eed9a71415d401faa4a">AeroDyn_Interface_Wrapper::CopyStates_Pred_to_Curr</a></div><div class="ttdeci">void CopyStates_Pred_to_Curr()</div><div class="ttdoc">Wrapper to the FORTRAN subroutine of the same name (see AeroDyn_Interface project)</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:285</div></div>
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_aba4f03bde29cc7fc61556325ebd40c64"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#aba4f03bde29cc7fc61556325ebd40c64">AeroDyn_Interface_Wrapper::InitAerodyn</a></div><div class="ttdeci">void InitAerodyn(const char *inputFilename, const char *outputFilename, double timestep, int numBlades, double hubRadius, double precone, bool useAddedMass, double coeffAddedMass, const Vector3d &amp;hubPosition, const Matrix3d &amp;hubOrientation, const Vector3d &amp;hubVel, const Vector3d &amp;hubAcc, const Vector3d &amp;hubRotationalVel, const Vector3d &amp;hubRotationalAcc, double bladePitch)</div><div class="ttdoc">Initializes AeroDyn by loading input files and setting initial hub state.</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:100</div></div>
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_a8b049f70154c822b2ca5f5a82d5b101c"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#a8b049f70154c822b2ca5f5a82d5b101c">AeroDyn_Interface_Wrapper::UpdateStates</a></div><div class="ttdeci">void UpdateStates()</div><div class="ttdoc">Updates from the current states at time_curr to time_next, and stores the new states in the predicted...</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:280</div></div>
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_a2a17f25396dc6de8d62011ab6bc61fd3"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#a2a17f25396dc6de8d62011ab6bc61fd3">AeroDyn_Interface_Wrapper::GetBladeNodePositions</a></div><div class="ttdeci">void GetBladeNodePositions(std::vector&lt; double &gt; &amp;bladeNodePositions)</div><div class="ttdoc">Once updateHubState has been called, we call this to get where those hub kinematics put the blade nod...</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:296</div></div>
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_a83efebceeba09a5730bbd4627e7f229d"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#a83efebceeba09a5730bbd4627e7f229d">AeroDyn_Interface_Wrapper::Set_Inputs_Hub</a></div><div class="ttdeci">void Set_Inputs_Hub(double time, const Vector3d &amp;hubPosition, const Matrix3d &amp;hubOrientation, const Vector3d &amp;hubVel, const Vector3d &amp;hubAcc, const Vector3d &amp;hubAngularVel, const Vector3d &amp;hubAngularAcc, double bladePitch)</div><div class="ttdoc">Updates the hub motion variables, changing the positions of the nodes accordingly.</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:196</div></div>
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_a008b9580fca86c4edaa714b716b82f2c"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#a008b9580fca86c4edaa714b716b82f2c">AeroDyn_Interface_Wrapper::Set_Inputs_Inflow</a></div><div class="ttdeci">void Set_Inputs_Inflow(const std::vector&lt; double &gt; &amp;inflowVel, const std::vector&lt; double &gt; &amp;inflowAcc)</div><div class="ttdoc">Sets the flow velocity and acceleration at the next time-step. Note, inflow velocities are in global ...</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:245</div></div>
<div class="ttc" id="aclass_aero_dyn___interface___wrapper_html_a5669533a22e0f6ba60c30c6d5f6a2306"><div class="ttname"><a href="class_aero_dyn___interface___wrapper.html#a5669533a22e0f6ba60c30c6d5f6a2306">AeroDyn_Interface_Wrapper::Advance_InputWindow</a></div><div class="ttdeci">void Advance_InputWindow()</div><div class="ttdoc">Cycles the two inputs: curr_input=next_input.</div><div class="ttdef"><b>Definition:</b> AeroDyn_Interface_Wrapper.cpp:254</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
